<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized AMI Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-color: #6a11cb;
            --secondary-color: #2575fc;
            --background-color: #f0f2f5;
            --card-background: #ffffff;
            --text-color: #333;
            --header-text-color: #ffffff;
            --border-radius: 12px;
            --shadow: 0 4px 6px rgba(0,0,0,0.1);
            --ai-message-bg: #e9ecef;
            --success-color: #27ae60;
            --error-color: #e74c3c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: var(--header-text-color);
            padding: 1rem;
            text-align: center;
            box-shadow: var(--shadow);
            z-index: 10;
        }
        h1 { font-size: 1.5rem; margin: 0; }

        main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            box-sizing: border-box;
            overflow-y: hidden;
        }

        #chat-window {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background: var(--card-background);
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .chat-message {
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            border-radius: var(--border-radius);
            max-width: 85%;
            line-break: anywhere;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeIn 0.3s forwards;
        }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }

        .user-message { background-color: var(--secondary-color); color: white; margin-left: auto; text-align: left; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--text-color); margin-right: auto; }
        .system-message { text-align: center; color: #888; font-style: italic; font-size: 0.9em; margin-bottom: 1rem; }

        .input-container {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            background: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        #chat-input { flex-grow: 1; border: 1px solid #ccc; border-radius: var(--border-radius); padding: 0.75rem; font-size: 1rem; }
        #api-key-input { flex-grow: 1; border-radius: var(--border-radius); padding: 0.75rem; font-size: 1rem; border: 1px solid var(--primary-color); }
        
        .chat-button {
            border: none;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--border-radius);
            padding: 0 1.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .chat-button:hover { background-color: var(--secondary-color); }
        .chat-button:disabled { background-color: #ccc; cursor: not-allowed; }

        .scenario-results {
            padding: 1rem;
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            margin-top: 1rem;
            background: #f9f9f9;
        }

        .progress-indicator {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <header><h1>Optimized AMI Calculator</h1></header>
    <main>
        <div id="chat-window"></div>
        <div id="api-key-container" class="input-container">
            <input type="password" id="api-key-input" placeholder="Enter your Gemini API Key and press Enter...">
        </div>
        <div id="chat-input-container" class="input-container" style="display: none;">
            <input type="text" id="chat-input" placeholder="Type your message here...">
            <button id="upload-btn" class="chat-button" title="Upload Excel File">📎</button>
            <button id="send-btn" class="chat-button">Send</button>
        </div>
    </main>
    <input type="file" id="file-input" accept=".xlsx, .xls" style="display: none;">

    <script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

        // --- STATE ---
        let state = { apiKey: null, buildingData: null, isProcessing: false };

        // --- DOM ELEMENTS ---
        const chatWindow = document.getElementById('chat-window');
        const apiKeyContainer = document.getElementById('api-key-container');
        const apiKeyInput = document.getElementById('api-key-input');
        const chatInputContainer = document.getElementById('chat-input-container');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const fileInput = document.getElementById('file-input');

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', initializeApp);
        apiKeyInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleApiKey());
        sendBtn.addEventListener('click', handleUserMessage);
        chatInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleUserMessage());
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        
        // --- INITIALIZATION ---
        async function initializeApp() {
            console.log("🚀 Initializing app...");
            const storedKey = localStorage.getItem('geminiApiKey');
            if (storedKey) {
                await verifyAndSetApiKey(storedKey, true);
            } else {
                addMessage("Hello! To begin, please enter your Gemini API key.", 'ai');
            }
        }
        
        // --- API KEY HANDLING ---
        async function handleApiKey() {
            await verifyAndSetApiKey(apiKeyInput.value);
        }

        async function verifyAndSetApiKey(key, isAutoLoad = false) {
            key = key.trim();
            if (!key) {
                return addMessage("Please provide an API key.", 'system');
            }

            apiKeyInput.disabled = true;
            if (!isAutoLoad) addMessage("Verifying API Key...", 'system');

            try {
                const genAI = new GoogleGenerativeAI(key);
                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
                await model.countTokens("test");
                
                state.apiKey = key;
                state.genAI = genAI;
                state.model = model;
                localStorage.setItem('geminiApiKey', key);
                
                if (!isAutoLoad) addMessage("Success! API Key is valid and has been saved for future sessions.", 'system');
                
                showChatInput();
            } catch (error) {
                console.error("API Key verification failed:", error);
                addMessage("API Key is invalid. Please try again.", 'system');
                apiKeyInput.disabled = false;
            }
        }

        // --- UI FLOW ---
        function showChatInput() {
            apiKeyContainer.style.display = 'none';
            chatInputContainer.style.display = 'flex';
            chatInput.focus();
        }

        // --- FILE HANDLING ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    state.buildingData = normalizeAndExtractUnits(jsonData);
                    
                    if (state.buildingData && state.buildingData.length > 0) {
                        const totalSF = state.buildingData.reduce((sum, unit) => sum + unit.sf, 0);
                        addMessage(`File uploaded successfully! Found ${state.buildingData.length} units with ${totalSF.toFixed(1)} total square footage.`, 'system');
                    } else {
                        addMessage("Error: No valid unit data found. Please check your Excel file format.", 'system');
                    }
                } catch (error) {
                    console.error("File processing error:", error);
                    addMessage("Error processing file: " + error.message, 'system');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // --- CONVERSATION ---
        async function handleUserMessage() {
            const userText = chatInput.value.trim();
            if (!userText || state.isProcessing) return;

            addMessage(userText, 'user');
            chatInput.value = '';
            state.isProcessing = true;
            updateUI();
            
            try {
                const prompt = buildMasterPrompt(userText);
                const result = await state.model.generateContent(prompt);
                const responseText = result.response.text();

                if (responseText.includes("ACTION_CALCULATE")) {
                    const jsonPart = responseText.substring(responseText.indexOf('{'));
                    try {
                        const requirements = JSON.parse(jsonPart);
                        await runAndDisplayScenariosAsync(requirements);
                    } catch (parseError) {
                        console.error("JSON parse error:", parseError);
                        addMessage("Error parsing AI response. Please try again.", 'ai');
                    }
                } else {
                    addMessage(responseText, 'ai');
                }
            } catch (error) {
                console.error("AI Error:", error);
                addMessage("An error occurred with the AI. Please try again.", 'ai');
            } finally {
                state.isProcessing = false;
                updateUI();
            }
        }
        
        // --- UTILITIES ---
        function updateUI() {
            const hasKey = !!state.apiKey;
            const isProcessing = state.isProcessing;
            chatInput.disabled = !hasKey || isProcessing;
            sendBtn.disabled = !hasKey || isProcessing;
            uploadBtn.disabled = !hasKey || isProcessing;
            chatInput.placeholder = isProcessing ? "Thinking..." : "Type your message here...";
        }

        function addMessage(text, role, isHTML = false) {
            const el = document.createElement('div');
            el.className = `chat-message ${role}-message`;
            if (isHTML) el.innerHTML = text;
            else el.textContent = text;
            chatWindow.appendChild(el);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function buildMasterPrompt(userText) {
             const buildingDataSummary = state.buildingData ? {
                 totalUnits: state.buildingData.length,
                 totalSquareFootage: state.buildingData.reduce((s, u) => s + u.sf, 0),
             } : null;

             return `
                You are an expert calculation tool for NYC affordable housing. Your only goal is to extract requirements from the user's text and trigger a calculation.
                **Core Directive: CALCULATE, DON'T CONSULT.**
                - Your job is to run the numbers.
                - **NEVER** ask for external documents.
                - **MAKE REASONABLE ASSUMPTIONS.** 
                
                **AMI DISTRIBUTION RULES:**
                - When user says "40% AMI is required" with "average should still be 60% AMI", this means:
                  * 20% of units at 40% AMI (for deeper affordability)
                  * 80% of units at 60% AMI (to achieve 60% average)
                - When user says just "40% AMI units", assume 100% at 40% AMI
                
                **CONTEXT:**
                - Building Data Summary: ${JSON.stringify(buildingDataSummary)}.
                
                **USER'S LATEST MESSAGE:**
                "${userText}"
                
                **YOUR TASK:**
                1. Immediately analyze the user's message.
                2. Extract these requirements:
                   - targetSF: The required square footage (number)
                   - amiDistribution: Array of AMI percentages (e.g., [40, 60] for mixed distribution)
                   - requiredFloors: Array of floor numbers (e.g., [5, 6])
                3. If you can extract requirements, your ONLY response must be "ACTION_CALCULATE" followed by the JSON: {"targetSF": ..., "amiDistribution": [...], "requiredFloors": [...]}.
                4. If missing target SF, you may ask for that one thing.
                
                **EXAMPLES:**
                - "2,043.3 sf of affordable is required. 40% AMI units are required. There should be an affordable unit on floors 5 and 6."
                  → {"targetSF": 2043.3, "amiDistribution": [40, 60], "requiredFloors": [5, 6]}
                - "I need 1500 sf at 50% AMI"
                  → {"targetSF": 1500, "amiDistribution": [50], "requiredFloors": []}
                - "40% AMI is required, average should be 60% AMI"
                  → {"targetSF": [extract from context], "amiDistribution": [40, 60], "requiredFloors": []}
              `;
         }

        // --- OPTIMIZED CALCULATION ENGINE ---
        async function runAndDisplayScenariosAsync(requirements) {
            if (!state.buildingData) {
                addMessage("Please upload a building data file first.", 'ai');
                return;
            }

            // Show progress indicator
            addMessage('<div class="progress-indicator">⏳ Calculating optimal scenarios...</div>', 'ai', true);

            // Use requestIdleCallback for better performance
            return new Promise((resolve) => {
                const scenarios = [];
                let scenarioIndex = 0;
                const scenarioConfigs = [
                    { name: "Exact Target Match", strategy: "exact", description: "Aims for the closest SF match to requirements" },
                    { name: "Minimum Units Strategy", strategy: "minimize_units", description: "Uses largest units to minimize count" },
                    { name: "Maximum Affordability", strategy: "maximize_units", description: "Uses smallest units to maximize count" },
                    { name: "Balanced Floor Distribution", strategy: "balanced_floors", description: "Includes required floors, then fills remainder" }
                ];

                function processNextScenario() {
                    if (scenarioIndex >= scenarioConfigs.length) {
                        displayResults(scenarios);
                        resolve();
                        return;
                    }

                    const config = scenarioConfigs[scenarioIndex];
                    const scenario = generateOptimizedScenario(config.name, config.description, requirements, config.strategy);
                    scenarios.push(scenario);
                    scenarioIndex++;

                    // Use setTimeout to prevent blocking
                    setTimeout(processNextScenario, 10);
                }

                processNextScenario();
            });
        }

        function generateOptimizedScenario(title, reasoning, requirements, strategy) {
            let availableUnits = [...state.buildingData];
            
            // Pre-filter units based on required floors if specified
            if (requirements.requiredFloors && requirements.requiredFloors.length > 0) {
                const requiredFloorUnits = availableUnits.filter(u => requirements.requiredFloors.includes(u.floor));
                const remainingUnits = availableUnits.filter(u => !requirements.requiredFloors.includes(u.floor));
                
                // Different sorting strategies
                switch (strategy) {
                    case "exact":
                        requiredFloorUnits.sort((a, b) => a.sf - b.sf);
                        remainingUnits.sort((a, b) => a.sf - b.sf);
                        break;
                    case "minimize_units":
                        requiredFloorUnits.sort((a, b) => b.sf - a.sf);
                        remainingUnits.sort((a, b) => b.sf - a.sf);
                        break;
                    case "maximize_units":
                        requiredFloorUnits.sort((a, b) => a.sf - b.sf);
                        remainingUnits.sort((a, b) => a.sf - b.sf);
                        break;
                    case "balanced_floors":
                        requiredFloorUnits.sort((a, b) => a.sf - b.sf);
                        remainingUnits.sort((a, b) => a.sf - b.sf);
                        break;
                }
                
                availableUnits = [...requiredFloorUnits, ...remainingUnits];
            } else {
                // Sort all units based on strategy
                switch (strategy) {
                    case "exact":
                    case "maximize_units":
                    case "balanced_floors":
                        availableUnits.sort((a, b) => a.sf - b.sf);
                        break;
                    case "minimize_units":
                        availableUnits.sort((a, b) => b.sf - a.sf);
                        break;
                }
            }

            // Use optimized algorithms instead of brute force
            let selectedUnits;
            switch (strategy) {
                case "exact":
                    selectedUnits = findOptimalCombinationDP(availableUnits, requirements.targetSF);
                    break;
                case "minimize_units":
                    selectedUnits = findMinimumUnitsGreedy(availableUnits, requirements.targetSF);
                    break;
                case "maximize_units":
                    selectedUnits = findMaximumUnitsGreedy(availableUnits, requirements.targetSF);
                    break;
                case "balanced_floors":
                    selectedUnits = findBalancedFloorCombination(availableUnits, requirements.targetSF, requirements.requiredFloors);
                    break;
                default:
                    selectedUnits = findOptimalCombinationDP(availableUnits, requirements.targetSF);
            }
            
            const totalSF = selectedUnits.reduce((sum, unit) => sum + unit.sf, 0);
            
            // Assign AMI levels based on distribution
            const amiLevels = requirements.amiDistribution || [40];
            selectedUnits.forEach((unit, index) => {
                if (amiLevels.length === 2) {
                    const threshold = Math.floor(selectedUnits.length * 0.2);
                    unit.amiLevel = index < threshold ? amiLevels[0] : amiLevels[1];
                } else {
                    unit.amiLevel = amiLevels[0];
                }
            });

            return { title, reasoning, units: selectedUnits, totalSF };
        }

        // Optimized algorithms that scale better

        function findOptimalCombinationDP(units, targetSF) {
            // Dynamic Programming approach - much more efficient than brute force
            const n = Math.min(units.length, 50); // Limit for performance
            const target = Math.floor(targetSF);
            const tolerance = 100; // Allow some flexibility
            
            // DP table: dp[i][w] = best combination for first i units with target w
            const dp = Array(n + 1).fill(null).map(() => Array(target + tolerance + 1).fill(null));
            
            // Initialize base case
            for (let w = 0; w <= target + tolerance; w++) {
                dp[0][w] = { units: [], totalSF: 0 };
            }
            
            // Fill DP table
            for (let i = 1; i <= n; i++) {
                const unit = units[i - 1];
                const unitSF = Math.floor(unit.sf);
                
                for (let w = 0; w <= target + tolerance; w++) {
                    // Don't take current unit
                    dp[i][w] = dp[i - 1][w];
                    
                    // Take current unit if possible and better
                    if (unitSF <= w && dp[i - 1][w - unitSF]) {
                        const newCombination = {
                            units: [...dp[i - 1][w - unitSF].units, unit],
                            totalSF: dp[i - 1][w - unitSF].totalSF + unit.sf
                        };
                        
                        if (!dp[i][w] || 
                            Math.abs(newCombination.totalSF - targetSF) < Math.abs(dp[i][w].totalSF - targetSF)) {
                            dp[i][w] = newCombination;
                        }
                    }
                }
            }
            
            // Find best result
            let bestResult = { units: [], totalSF: 0 };
            let bestDiff = Infinity;
            
            for (let w = target; w <= target + tolerance; w++) {
                if (dp[n][w]) {
                    const diff = Math.abs(dp[n][w].totalSF - targetSF);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestResult = dp[n][w];
                    }
                }
            }
            
            return bestResult.units;
        }

        function findMinimumUnitsGreedy(units, targetSF) {
            // Greedy algorithm: largest units first
            const sorted = [...units].sort((a, b) => b.sf - a.sf);
            const selected = [];
            let currentSF = 0;
            
            for (const unit of sorted) {
                if (currentSF >= targetSF) break;
                if (selected.length >= 15) break; // Reasonable limit
                
                selected.push(unit);
                currentSF += unit.sf;
            }
            
            return selected;
        }

        function findMaximumUnitsGreedy(units, targetSF) {
            // Greedy algorithm: smallest units first
            const sorted = [...units].sort((a, b) => a.sf - b.sf);
            const selected = [];
            let currentSF = 0;
            
            for (const unit of sorted) {
                if (currentSF + unit.sf > targetSF + 100) break; // Small tolerance
                if (selected.length >= 20) break; // Reasonable limit
                
                selected.push(unit);
                currentSF += unit.sf;
                
                if (currentSF >= targetSF) break;
            }
            
            return selected;
        }

        function findBalancedFloorCombination(units, targetSF, requiredFloors) {
            // Ensure at least one unit from each required floor, then optimize
            const requiredFloorUnits = units.filter(u => requiredFloors.includes(u.floor));
            const otherUnits = units.filter(u => !requiredFloors.includes(u.floor));
            
            let selected = [];
            let currentSF = 0;
            
            // Add one unit from each required floor (smallest first for balance)
            const sortedRequired = requiredFloorUnits.sort((a, b) => a.sf - b.sf);
            const usedFloors = new Set();
            
            for (const unit of sortedRequired) {
                if (!usedFloors.has(unit.floor) && selected.length < 10) {
                    selected.push(unit);
                    currentSF += unit.sf;
                    usedFloors.add(unit.floor);
                }
            }
            
            // Fill remaining with best fit from all available units
            const remaining = [...requiredFloorUnits.filter(u => !selected.includes(u)), ...otherUnits];
            remaining.sort((a, b) => a.sf - b.sf);
            
            for (const unit of remaining) {
                if (currentSF >= targetSF) break;
                if (selected.length >= 15) break;
                
                selected.push(unit);
                currentSF += unit.sf;
            }
            
            return selected;
        }

        function displayResults(scenarios) {
            let resultHTML = '<div class="scenario-results"><h3>AMI Scenario Results</h3>';
            scenarios.forEach((scenario, index) => {
                resultHTML += `<h4>${index + 1}. ${scenario.title}</h4>`;
                resultHTML += `<p><em>${scenario.reasoning}</em></p>`;
                resultHTML += `<p><strong>Result:</strong> ${scenario.units.length} units, ${scenario.totalSF.toFixed(1)} sf</p>`;
                resultHTML += '<ul>';
                scenario.units.forEach(unit => {
                    const amiColor = getAMIColor(unit.amiLevel);
                    resultHTML += `<li style="color: ${amiColor};">${unit.unit} (${unit.sf.toFixed(1)} sf) - ${unit.amiLevel}% AMI</li>`;
                });
                resultHTML += '</ul>';
            });
            resultHTML += '</div>';
            
            // Remove progress indicator and add results
            const messages = chatWindow.querySelectorAll('.ai-message');
            const lastMessage = messages[messages.length - 1];
            if (lastMessage && lastMessage.innerHTML.includes('progress-indicator')) {
                lastMessage.remove();
            }
            
            addMessage(resultHTML, 'ai', true);
        }

        function normalizeAndExtractUnits(jsonData) {
            if (!jsonData || jsonData.length === 0) return null;

            const units = [];
            const sfColumns = [
                'SF', 'sf', 'SQUARE_FEET', 'square_feet', 'NET SF', 'NET_SF', 'sqft', 'SQFT',
                'Square Feet', 'square feet', 'NET SF', 'Net SF', 'net sf', 'NET_SQFT', 'net_sqft',
                'SQUARE_FT', 'square_ft', 'SQ_FT', 'sq_ft', 'AREA', 'area', 'SIZE', 'size'
            ];
            const bedColumns = [
                'BED', 'bed', 'BEDROOMS', 'bedrooms', 'BEDS', 'beds',
                'Bedrooms', 'BEDROOM', 'bedroom', 'BED_COUNT', 'bed_count', 'ROOMS', 'rooms'
            ];
            const floorColumns = [
                'FLOOR', 'floor', 'LEVEL', 'level',
                'FLOOR_NUM', 'floor_num', 'LEVEL_NUM', 'level_num', 'STORY', 'story', 'STORIES', 'stories'
            ];
            const unitColumns = [
                'UNIT', 'unit', 'UNIT_NUMBER', 'unit_number', 'APT', 'apt',
                'APARTMENT', 'apartment', 'UNIT_ID', 'unit_id', 'NUMBER', 'number', 'ID', 'id'
            ];

            const availableColumns = Object.keys(jsonData[0]);
            const foundSfColumn = availableColumns.find(col => sfColumns.some(sfCol => col.toLowerCase().includes(sfCol.toLowerCase())));
            const foundBedColumn = availableColumns.find(col => bedColumns.some(bedCol => col.toLowerCase().includes(bedCol.toLowerCase())));
            const foundFloorColumn = availableColumns.find(col => floorColumns.some(floorCol => col.toLowerCase().includes(floorCol.toLowerCase())));
            const foundUnitColumn = availableColumns.find(col => unitColumns.some(unitCol => col.toLowerCase().includes(unitCol.toLowerCase())));

            jsonData.forEach((row, index) => {
                let sf = null, bed = null, floor = null, unit = null;

                if (foundSfColumn) sf = parseFloat(row[foundSfColumn]);
                if (foundBedColumn) bed = parseInt(row[foundBedColumn]);
                if (foundFloorColumn) floor = parseInt(row[foundFloorColumn]);
                if (foundUnitColumn) unit = String(row[foundUnitColumn]);

                if (sf && !isNaN(sf) && sf > 0) {
                    units.push({
                        sf: sf,
                        bed: bed || 0,
                        floor: floor || 1,
                        unit: unit || `Unit_${index + 1}`,
                        amiLevel: 40
                    });
                }
            });

            return units.length > 0 ? units : null;
        }

        function getAMIColor(amiLevel) {
            if (amiLevel <= 40) return '#e74c3c'; // Red
            if (amiLevel <= 50) return '#f39c12'; // Orange
            if (amiLevel <= 60) return '#f1c40f'; // Yellow
            if (amiLevel <= 70) return '#2ecc71'; // Light Green
            return '#27ae60'; // Green
        }

    </script>
</body>
</html>